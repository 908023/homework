# 基于双向循环链表的约瑟夫环变体问题的C语言实现

要求如下：

> 采用双向循环链表解决约瑟夫问题：有n个人围成一圈，给定一个m<n，从第一个人开始计数，第m人出列，下一次从下一个人开始计数。奇数次顺时针循环遍历转动，偶数次逆时针循环遍历转动，直到只剩最后一个人，为优胜者。

## 程序设计思想
本程序由三部分组成：<br>
1. `clist.h`<br>
此头文件包括对双向循环链表基本结构体的定义，并声明了所有所需函数。
2. `clist.c`<br>
对`clist.h`中的函数做了定义。
3. `main.c`<br>
程序的主体部分。


由`clist.h` `clist.c`完成了双向循环链表的创建、插入、打印、判断等基本所需功能，`main.c`负责交互、删除、逻辑判断等工作。

## 函数变量说明

### `clist.h`&`clist.c`

#### 函数部分
- pHead ClistCreate()<br>
创建循环链表，返回值为新链表的地址。
- int ClistInsert(pHead ph, int pos, int val)<br>
在链表的pos位置插入元素val，正确插入返回1。
- void print(pHead ph)<br>
打印循环链表中的元素。
- int IsEmpty(pHead ph)<br>
判断链表是否为空，为空返回1，反之返回0。

#### 变量&自定结构部分
- Node<br>
结构体，双向循环链表的结点<br>
包括以下部分：<br>
    - data：int类型，为基本数据。
    - next：pNode类型,指向下一个结点。
    - pre：pNode类型,指向上一个结点。
- Head<br>
结构体，指向双向循环链表的头结点。<br>
包括以下部分：<br>
    - length：int类型，为双向循环链表的长度。
    - next：pNode类型，指向下一个结点。
- pHead<br>
Head*类型。
- pNode<br>
Node*类型。

### `main.c`
- m<br>
约瑟夫环的总人数。
- n<br>
出局者的报数。
- ph<br>
指向双向循环链表的头结点。

**循环内临时变量不表**

## 程序执行结果
```
请输入约瑟夫环的总人数：
> 5
请输入出局者的报数：
> 2
1 2 3 4 5 
出局顺序：
2  1  3  5  
链表中最后留下的是 4 
```
## 复杂度分析
### 时间复杂度分析
1. 链表创建与初始化

    - `ClistCreate()`：O(1)

    - 插入 m 个元素（逆向插入）：
每次头插法（`ClistInsert(ph, 0, i)`）的时间复杂度为 O(1)，总时间复杂度为 O(m)。

2. 约瑟夫环处理

    - 每次淘汰一个人需要两次移动（正向和逆向），每次移动 n-1 步，时间复杂度为 O(n)。

    - 需要淘汰 m-1 次，总时间复杂度为 O(m·n)。

**总时间复杂度：**

**<font size=5><center>O(m)+O(m⋅n)=O(m⋅n)</center></font>**

### 空间复杂度分析
- 链表存储 m 个节点，每个节点包含数据域和两个指针，占用空间为 O(m)。

- 其他临时变量（如指针、计数器等）为常数空间 O(1)。

**总空间复杂度：**

**<font size=5><center>O(m)</center></font>**
